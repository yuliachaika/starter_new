{"version":3,"sources":["_global.scss","_foundation.scss","style.css"],"names":[],"mappings":"AAAA,EACC,8BAAA,AAAsB,qBAAA,CACtB,KAGC,6BAA8B,CCoP1B,yCDrPN,KAGE,aAAc,CAKf,CC6OK,yCDrPN,KAME,aAAc,CAEf,CAED,KACC,SACA,gBAAiB,CACjB,6BAGA,wBACA,qBACA,gBACA,AACA,iBAAkB,CAClB,wBAGA,eACA,yHAAA,AE1B4B,oHF0B5B,AE1B4B,gHAAA,CAAC,gDAAgD,YAAY,CAAC,EAAE,oBAAoB,CAAC,WAAW,QAAQ,CAAC,IAAI,WAAW,YAAY,eAAe,CAAC,GAAG,SAAS,eAAe,eAAe,CAAC,WAAW,mBAAmB,mBAAmB,aAAa,CAAC","file":"style.css","sourcesContent":["* {\r\n\tbox-sizing: border-box;\r\n}\r\n\r\nhtml {\r\n\t -webkit-text-size-adjust: 100%;\r\n\t@include breakpoint(small only) {\r\n\t\tfont-size: 70%;\r\n\t}\r\n\t@include breakpoint(medium down) {\r\n\t\tfont-size: 80%;\r\n\t}\r\n}\r\n\r\nbody {\r\n\tmargin: 0;\r\n\tmin-height: 100vh; \r\n}\r\n\r\ninput, button, select, textarea{\r\n\t-webkit-appearance: none;\r\n\t-moz-appearance: none;\r\n\tappearance: none;\r\n\t-webkit-border-radius:0px;\r\n\tborder-radius: 0px;\r\n}\r\n\r\na, button, input, textarea  {\r\n\tcursor: pointer;\r\n\ttransition:\r\n\tborder-color .4s ease-in,\r\n\tcolor .4s ease-in,\r\n\ttext-shadow .4s ease-in,\r\n\tbackground-color .4s ease-in;\r\n\t&:focus {\r\n\t\toutline: none;\r\n\t}\r\n}\r\na {\r\n\ttext-decoration: none;\r\n}\r\n\r\nh1, h2, h3, p {\r\n\tmargin: 0; \r\n}\r\n\r\nimg {\r\n\twidth: 100%;\r\n\theight: auto;\r\n\toverflow: hidden; \r\n}\r\n\r\nul {\r\n\tmargin: 0;\r\n\tpadding-left: 0;\r\n\tlist-style: none;\r\n}\r\n\r\n.container {\r\n\tmax-width: rem-calc(1140); \r\n\tpadding: 0 rem-calc(15);\r\n\tmargin: 0 auto;\r\n}\r\n","// Foundation for Sites by ZURB\r\n// foundation.zurb.com\r\n// Licensed under MIT Open Source\r\n$global-font-size: 100% !default;\r\n\r\n@function rem-calc($values, $base: null) {\r\n  $rem-values: ();\r\n  $count: length($values);\r\n\r\n  // If no base is defined, defer to the global font size\r\n  @if $base == null {\r\n    $base: $global-font-size;\r\n  }\r\n\r\n  // If the base font size is a %, then multiply it by 16px\r\n  // This is because 100% font size = 16px in most all browsers\r\n  @if unit($base) == '%' {\r\n    $base: ($base / 100%) * 16px;\r\n  }\r\n\r\n  // Using rem as base allows correct scaling\r\n  @if unit($base) == 'rem' {\r\n    $base: strip-unit($base) * 16px;\r\n  }\r\n\r\n  @if $count == 1 {\r\n    @return -zf-to-rem($values, $base);\r\n  }\r\n\r\n  @for $i from 1 through $count {\r\n    $rem-values: append($rem-values, -zf-to-rem(nth($values, $i), $base));\r\n  }\r\n\r\n  @return $rem-values;\r\n}\r\n\r\n@function strip-unit($num) {\r\n  @return $num / ($num * 0 + 1);\r\n}\r\n// Converts a unitless, pixel, or rem value to em, for use in breakpoints.\r\n@function -zf-bp-to-em($value) {\r\n  // Pixel and unitless values are converted to rems\r\n  @if unit($value) == 'px' or unitless($value) {\r\n    $value: rem-calc($value, $base: 16px);\r\n  }\r\n\r\n  // Then the value is converted to ems\r\n  @return strip-unit($value) * 1em;\r\n}\r\n\r\n//\r\n@function -zf-to-rem($value, $base: null) {\r\n  // Check if the value is a number\r\n  @if type-of($value) != 'number' {\r\n    @warn inspect($value) + ' was passed to rem-calc(), which is not a number.';\r\n    @return $value;\r\n  }\r\n\r\n  // Transform em into rem if someone hands over 'em's\r\n  @if unit($value) == 'em' {\r\n    $value: strip-unit($value) * 1rem;\r\n  }\r\n\r\n  // Calculate rem if units for $value is not rem or em\r\n  @if unit($value) != 'rem' {\r\n    $value: strip-unit($value) / strip-unit($base) * 1rem;\r\n  }\r\n\r\n  // Turn 0rem into 0\r\n  @if $value == 0rem {\r\n    $value: 0;\r\n  }\r\n\r\n  @return $value;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n////\r\n/// @group breakpoints\r\n////\r\n\r\n/// A list of named breakpoints. You can use these with the `breakpoint()` mixin to quickly create media queries.\r\n/// @type Map\r\n$breakpoints: (\r\n  small: 0,\r\n  medium: 640px,\r\n  large: 1024px,\r\n  xlarge: 1200px,\r\n  xxlarge: 1440px,\r\n  // small: rem-calc(0),\r\n  // medium: rem-calc(640),\r\n  // large: rem-calc(1024),\r\n  // xlarge: rem-calc(1200),\r\n  // xxlarge: rem-calc(1440),\r\n) !default;\r\n\r\n/// The largest named breakpoint in which to include print as a media type\r\n/// @type Keyword\r\n$print-breakpoint: large !default;\r\n\r\n$-zf-zero-breakpoint: small !default;\r\n\r\n$-zf-breakpoints-keys: map-to-list($breakpoints, 'keys');\r\n\r\n@if nth(map-values($breakpoints), 1) != 0 {\r\n  @error 'Your smallest breakpoint (defined in $breakpoints) must be set to \"0\".';\r\n}\r\n@else {\r\n  $-zf-zero-breakpoint: nth(map-keys($breakpoints), 1);\r\n}\r\n\r\n/// All of the names in this list will be output as classes in your CSS, like `.small-12`, `.medium-6`, and so on. Each value in this list must also be in the `$breakpoints` map.\r\n/// @type List\r\n$breakpoint-classes: (small medium large) !default;\r\n\r\n/// Generates a media query string matching the input value. Refer to the documentation for the `breakpoint()` mixin to see what the possible inputs are.\r\n///\r\n/// @param {Keyword|Number} $val [small] - Breakpoint name, or px, rem, or em value to process.\r\n@function breakpoint($val: $-zf-zero-breakpoint) {\r\n  // Size or keyword\r\n  $bp: nth($val, 1);\r\n  // Value for max-width media queries\r\n  $bp-max: 0;\r\n  // Direction of media query (up, down, or only)\r\n  $dir: if(length($val) > 1, nth($val, 2), up);\r\n  // Eventual output\r\n  $str: '';\r\n  // Is it a named media query?\r\n  $named: false;\r\n\r\n  // Orientation media queries have a unique syntax\r\n  @if $bp == 'landscape' or $bp == 'portrait' {\r\n    @return '(orientation: #{$bp})';\r\n  }\r\n  @else if $bp == 'retina' {\r\n    @return '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)';\r\n  }\r\n\r\n  // Try to pull a named breakpoint out of the $breakpoints map\r\n  @if type-of($bp) == 'string' {\r\n    @if map-has-key($breakpoints, $bp) {\r\n      @if $dir == 'only' or $dir == 'down' {\r\n        $bp-max: -zf-map-next($breakpoints, $bp);\r\n      }\r\n\r\n      $bp: map-get($breakpoints, $bp);\r\n      $named: true;\r\n    }\r\n    @else {\r\n      $bp: 0;\r\n      @warn 'breakpoint(): \"#{$val}\" is not defined in your $breakpoints setting.';\r\n    }\r\n  }\r\n\r\n  // Convert any pixel, rem, or unitless value to em\r\n  $bp: -zf-bp-to-em($bp);\r\n  @if $bp-max {\r\n    $bp-max: -zf-bp-to-em($bp-max) - (1/16);\r\n  }\r\n\r\n  // Conditions to skip media query creation\r\n  // - It's a named breakpoint that resolved to \"0 down\" or \"0 up\"\r\n  // - It's a numeric breakpoint that resolved to \"0 \" + anything\r\n  @if $bp > 0em or $dir == 'only' or $dir == 'down' {\r\n    // `only` ranges use the format `(min-width: n) and (max-width: n)`\r\n    @if $dir == 'only' {\r\n      // Only named media queries can have an \"only\" range\r\n      @if $named == true {\r\n        // Only use \"min-width\" if the floor is greater than 0\r\n        @if $bp > 0em {\r\n          $str: $str + '(min-width: #{$bp})';\r\n\r\n          // Only add \"and\" to the media query if there's a ceiling\r\n          @if $bp-max != null {\r\n            $str: $str + ' and ';\r\n          }\r\n        }\r\n\r\n        // Only use \"max-width\" if there's a ceiling\r\n        @if $bp-max != null {\r\n          $str: $str + '(max-width: #{$bp-max})';\r\n        }\r\n      }\r\n      @else {\r\n        @warn 'breakpoint(): Only named media queries can have an `only` range.';\r\n      }\r\n    }\r\n\r\n    // `down` ranges use the format `(max-width: n)`\r\n    @else if $dir == 'down' {\r\n      $max: if($named, $bp-max, $bp);\r\n\r\n      // Skip media query creation if input value is exactly \"0 down\",\r\n      // unless the function was called as \"small down\", in which case it's just \"small only\"\r\n      @if $named or $bp > 0em {\r\n        @if $max != null {\r\n          $str: $str + '(max-width: #{$max})';\r\n        }\r\n      }\r\n    }\r\n\r\n    // `up` ranges use the format `(min-width: n)`\r\n    @else if $bp > 0em {\r\n      $str: $str + '(min-width: #{$bp})';\r\n    }\r\n  }\r\n\r\n  @return $str;\r\n}\r\n\r\n/// Wraps a media query around the content you put inside the mixin. This mixin accepts a number of values:\r\n///  - If a string is passed, the mixin will look for it in the `$breakpoints` map, and use a media query there.\r\n///  - If a pixel value is passed, it will be converted to an em value using `$global-font-size` as the base.\r\n///  - If a rem value is passed, the unit will be changed to em.\r\n///  - If an em value is passed, the value will be used as-is.\r\n///\r\n/// @param {Keyword|Number} $value - Breakpoint name, or px, rem, or em value to process.\r\n///\r\n/// @output If the breakpoint is \"0px and larger\", outputs the content as-is. Otherwise, outputs the content wrapped in a media query.\r\n@mixin breakpoint($value) {\r\n  $str: breakpoint($value);\r\n  $bp: index($-zf-breakpoints-keys, $value);\r\n  $pbp: index($-zf-breakpoints-keys, $print-breakpoint);\r\n\r\n  $old-zf-size: null;\r\n\r\n  // Make breakpoint size available as a variable\r\n  @if global-variable-exists(-zf-size) {\r\n    $old-zf-size: $-zf-size;\r\n  }\r\n  $-zf-size: nth($value, 1) !global; // get the first value to account for `only` and `down` keywords\r\n\r\n  // If $str is still an empty string, no media query is needed\r\n  @if $str == '' {\r\n    @content;\r\n  }\r\n\r\n  // Otherwise, wrap the content in a media query\r\n  @else {\r\n    // For named breakpoints less than or equal to $print-breakpoint, add print to the media types\r\n    @if $bp != null and $bp <= $pbp {\r\n      @media print, screen and #{$str} {\r\n        @content;\r\n       }\r\n    }\r\n    @else {\r\n      @media screen and #{$str} {\r\n        @content;\r\n      }\r\n    }\r\n  }\r\n\r\n  @if $old-zf-size != null {\r\n    // Restore the old breakpoint size\r\n    $-zf-size: $old-zf-size !global;\r\n  } @else {\r\n    $-zf-size: null !global;\r\n  }\r\n}\r\n\r\n/// Convers the breakpoints map to a URL-encoded string, like this: `key1=value1&key2=value2`. The value is then dropped into the CSS for a special `<meta>` tag, which is read by the Foundation JavaScript. This is how we transfer values from Sass to JavaScript, so they can be defined in one place.\r\n/// @access private\r\n///\r\n/// @param {Map} $map - Map to convert.\r\n///\r\n/// @returns {String} A string containing the map's contents.\r\n@function -zf-bp-serialize($map) {\r\n  $str: '';\r\n  @each $key, $value in $map {\r\n    $str: $str + $key + '=' + -zf-bp-to-em($value) + '&';\r\n  }\r\n  $str: str-slice($str, 1, -2);\r\n\r\n  @return $str;\r\n}\r\n\r\n/// Find the next key in a map.\r\n/// @access private\r\n///\r\n/// @param {Map} $map - Map to traverse.\r\n/// @param {Mixed} $key - Key to use as a starting point.\r\n///\r\n/// @returns {Mixed} The value for the key after `$key`, if `$key` was found. If `$key` was not found, or `$key` was the last value in the map, returns `null`.\r\n@function -zf-map-next($map, $key) {\r\n\r\n  // Store the keys of the map as a list\r\n  $values: map-keys($map);\r\n\r\n  $i: 0;\r\n\r\n  // If the Key Exists, Get the index of the key within the map and add 1 to it for the next breakpoint in the map\r\n  @if (map-has-key($map, $key)) {\r\n    $i: index($values, $key) + 1;\r\n  }\r\n\r\n  // If the key doesn't exist, or it's the last key in the map, return null\r\n  @if ($i > length($map) or $i == 0) {\r\n    @return null;\r\n  }\r\n  // Otherwise, return the value\r\n  @else {\r\n    @return map-get($map, nth($values, $i));\r\n  }\r\n\r\n}\r\n\r\n/// Return a list of our named breakpoints less than $key. Useful for dealing with\r\n/// responsive gutters for the grid.\r\n/// @access private\r\n///\r\n/// @param {String} $key - Key to use as last breakpoint.\r\n///\r\n/// @returns {Array} The list of breakpoints up to and. If $key is auto, returns breakpoints above the zero\r\n@function -zf-breakpoints-less-than($key) {\r\n  $list: ();\r\n  $found_key: false;\r\n\r\n  @each $name in $-zf-breakpoints-keys {\r\n    @if ($name == $key) {\r\n      $found_key: true;\r\n    }\r\n    @if not $found_key {\r\n      $list: append($list, $name);\r\n    }\r\n  }\r\n  @return $list;\r\n}\r\n\r\n/// Return a list of our named breakpoints less than $key. Useful for dealing with\r\n/// responsive gutters for the grid.\r\n/// @access private\r\n///\r\n/// @param {String} $breakpoing - a named or non-named breakpoing.\r\n///\r\n/// @returns {Array} The list of breakpoints up to and. If $key is auto, returns breakpoints above the zero\r\n@function -zf-closest-named-breakpoint($breakpoint) {\r\n  $last: $-zf-zero-breakpoint;\r\n  $found: false;\r\n\r\n  $value: unitless-calc($breakpoint, 1px);\r\n  @each $key, $val in $breakpoints {\r\n    @if not $found {\r\n      @if unitless-calc($val) > $value {\r\n        $found: true;\r\n      } @else {\r\n        $last: $key;\r\n      }\r\n    }\r\n  }\r\n\r\n  @return $last;\r\n}\r\n\r\n/// Get a value for a breakpoint from a responsive config map or single value.\r\n/// - If the config is a single value, return it regardless of `$value`.\r\n/// - If the config is a map and has the key `$value`, the exact breakpoint value is returned.\r\n/// - If the config is a map and does *not* have the breakpoint, the value matching the next lowest breakpoint in the config map is returned.\r\n/// @access private\r\n///\r\n/// @param {Number|Map} $map - Responsive config map or single value.\r\n/// @param {Keyword} $value - Breakpoint name to use.\r\n///\r\n/// @return {Mixed} The corresponding breakpoint value.\r\n@function -zf-get-bp-val($map, $value) {\r\n  // If the given map is a single value, return it\r\n  @if type-of($map) == 'number' {\r\n    @return $map;\r\n  }\r\n\r\n\r\n  // Check if the breakpoint name exists globally\r\n  @if not map-has-key($breakpoints, $value) {\r\n    @if type-of($value) == 'number' {\r\n      $value: -zf-closest-named-breakpoint($value);\r\n    } @else {\r\n      @return null;\r\n    }\r\n  }\r\n  // Check if the breakpoint name exists in the local config map\r\n  @else if map-has-key($map, $value) {\r\n    // If it does, just return the value\r\n    @return map-get($map, $value);\r\n  }\r\n  // Otherwise, find the next lowest breakpoint and return that value\r\n  @else {\r\n    $anchor: null;\r\n    $found: false;\r\n\r\n    @each $key, $val in $breakpoints {\r\n      @if not $found {\r\n        @if map-has-key($map, $key) {\r\n          $anchor: $key;\r\n        }\r\n        @if $key == $value {\r\n          $found: true;\r\n        }\r\n      }\r\n    }\r\n\r\n    @return map-get($map, $anchor);\r\n  }\r\n}\r\n\r\n@if map-has-key($breakpoints, small) {\r\n  $small-up: screen;\r\n  $small-only: unquote('screen and #{breakpoint(small only)}');\r\n}\r\n\r\n@if map-has-key($breakpoints, medium) {\r\n  $medium-up: unquote('screen and #{breakpoint(medium)}');\r\n  $medium-only: unquote('screen and #{breakpoint(medium only)}');\r\n}\r\n\r\n@if map-has-key($breakpoints, large) {\r\n  $large-up: unquote('screen and #{breakpoint(large)}');\r\n  $large-only: unquote('screen and #{breakpoint(large only)}');\r\n}\r\n\r\n@if map-has-key($breakpoints, xlarge) {\r\n  $xlarge-up: unquote('screen and #{breakpoint(xlarge)}');\r\n  $xlarge-only: unquote('screen and #{breakpoint(xlarge only)}');\r\n}\r\n\r\n@if map-has-key($breakpoints, xxlarge) {\r\n  $xxlarge-up: unquote('screen and #{breakpoint(xxlarge)}');\r\n}","*{box-sizing:border-box}html{-webkit-text-size-adjust:100%}@media screen and (max-width: 39.9375em){html{font-size:70%}}@media screen and (max-width: 63.9375em){html{font-size:80%}}body{margin:0;min-height:100vh}input,button,select,textarea{-webkit-appearance:none;-moz-appearance:none;appearance:none;-webkit-border-radius:0px;border-radius:0px}a,button,input,textarea{cursor:pointer;transition:border-color .4s ease-in,\r color .4s ease-in,\r text-shadow .4s ease-in,\r background-color .4s ease-in}a:focus,button:focus,input:focus,textarea:focus{outline:none}a{text-decoration:none}h1,h2,h3,p{margin:0}img{width:100%;height:auto;overflow:hidden}ul{margin:0;padding-left:0;list-style:none}.container{max-width:71.25rem;padding:0 .9375rem;margin:0 auto}\n"]}